<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta content="True" name="HandheldFriendly" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="/images/apple-touch-icon.png" />
  <title>webpack  sourcemap 选项多种模式的一些解释</title>
  <link rel="stylesheet" href="./build.css">
</head>
<body>
  <header id="header">
    <div id="brand">
      <a href="/"><strong>目田</strong></a>
    </div>
  </header>
  <div class="container">
  <article class="yue">
    <div class="hentry" itemscope="" itemtype="http://schema.org/Article">
      <h1 class="entry-title" itemprop="name">webpack  sourcemap 选项多种模式的一些解释</h1>
      <div class="entry-meta">
        
          <time class="updated" datetime="Sun Jan 10 2016 08:00:00 GMT+0800 (CST)" itemprop="datePublished" pubdate="">
            Sun Jan 10 2016
          </time>
        
      </div>
      <div class="entry-content" itemprop="articleBody">
        <p>有人说 Webpack 难用，原因是 sourcemap 有 7 种，本文就尝试解释下这些选项都是什么意思，不仅如此，本文还会分析如何用最好的姿势使用这些配置。</p>

<hr>

<p>先一项一项来看：</p>

<ul>
<li><p><code>eval</code> 文档上解释的很明白，每个模块都封装到 eval 包裹起来，并在后面添加 <code>//# sourceURL</code></p></li>
<li><p><code>source-map</code> 这是最原始的 source-map 实现方式，其实现是打包代码同时创建一个新的 sourcemap 文件， 并在打包文件的末尾添加 <code>//# sourceURL</code> 注释行告诉 JS 引擎文件在哪儿</p></li>
<li><p><code>hidden-source-map</code> 文档上也说了，就是 soucremap 但没注释，没注释怎么找文件呢？貌似只能靠后缀，譬如 <code>xxx/bundle.js</code> 文件，某些引擎会尝试去找 <code>xxx/bundle.js.map</code></p></li>
<li><p><code>inline-source-map</code> 为每一个文件添加 sourcemap 的 DataUrl，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 DataUrl 是包含一个文件完整 souremap 信息的 Base64 格式化后的字符串，而不是一个 url。</p></li>
<li><p><code>eval-source-map</code> 这个就是把 <code>eval</code> 的 sourceURL 换成了完整 souremap 信息的 DataUrl</p></li>
<li><p><code>cheap-source-map</code> 不包含列信息，不包含 loader 的 sourcemap，（譬如 babel 的 sourcemap）</p></li>
<li><p><code>cheap-module-source-map</code> 不包含列信息，同时 loader 的 sourcemap 也被简化为只包含对应行的。最终的 sourcemap 只有一份，它是 webpack 对 loader 生成的 sourcemap 进行简化，然后再次生成的。</p></li>
</ul>

<p>webpack 不仅支持这 7 种，而且它们还是可以任意组合的，就如文档所说，你可以设置 souremap 选项为 <code>cheap-module-inline-source-map</code>。</p>

<hr>

<p><strong>这么多模式，到底该用哪个？</strong></p>

<p><code>cheap-module-eval-source-map</code> 绝大多数情况下都会是最好的选择，这也是下版本 webpack 的默认选项。</p>

<p>相关解释：</p>

<ol>
<li>大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息，所以我们使用 cheap 模式可以大幅提高 souremap 生成的效率。</li>
<li>使用 eval 方式可大幅提高持续构建效率，参考 <a href="https://webpack.github.io/docs/configuration.html#devtool">webapck devtool 文档</a> 下方速度对比表格，这对经常需要边改边调的前端开发而言，非常重要！</li>
<li>使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用）。</li>
<li><code>eval-source-map</code> 使用 DataUrl 本身包含完整 sourcemap 信息，并不需要像 <code>sourceURL</code> 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率</li>
</ol>

<hr>

<p><strong>现实很残忍</strong></p>

<p>大部分浏览器对于 sourcemap 的支持都非常有限，支持最好的 V8 也仅限于在 debugger 里面支持 sourcemap，对于错误的调用栈，我们看到的结果还是各种指向 bundle.js  (除非是使用 eval + sourceURL  的方式)。</p>

<p>所以我做了 <a href="https://github.com/chemzqm/stack-source-map">stack-source-map</a> 这个项目，它能让 Chrome 的 error stack 支持所有的 webpack 打包模式，这样测试工具报错时，你就能第一时间找到错误处，后续还在考虑支持 vim 的 quickfix 列表，这样一旦出错，开发者就可以直接在编辑器内跳转到错误代码处。</p>

<p>如果您发现这个工具有什么问题，欢迎任何形式 <a href="https://github.com/chemzqm/stack-source-map/issues">反馈</a></p>

<hr>

<p>其实只要你了解 sourcemap 相关知识就会发现官方文档并不难懂，只是表述的比较简约，而且正是因为有了灵活的配置方式，我们才能在不同场景下获得最佳的效果。</p>


      </div>
    </div>
  </article>
  </div>
  <section class="comments yue">
    <div class="container">
        <div class="column-large">
            <div id="disqus_thread"></div>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a>.</noscript>
        </div>
    </div>
  </section>
  <script type="text/javascript">
    var disqus_shortname = 'zqm';
    var disqus_title = 'webpack  sourcemap 选项多种模式的一些解释';
    var disqus_identifier = '9';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
<footer>
  © Copyright by chemzqm
</footer>
</body>
</html>
